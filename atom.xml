<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>啊多子</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-06T14:54:16.086Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>wangly</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>webpack</title>
    <link href="http://yoursite.com/2017/12/06/webpack/"/>
    <id>http://yoursite.com/2017/12/06/webpack/</id>
    <published>2017-12-06T12:21:12.000Z</published>
    <updated>2017-12-06T14:54:16.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><h2 id="为什么要用webpack？"><a href="#为什么要用webpack？" class="headerlink" title="为什么要用webpack？"></a>为什么要用webpack？</h2><p>现如今网页丰富多样，很多网页都相当复杂，它们拥有复杂的js和各种依赖包，目前也有很多技术用于简化这些代码，例如：<br>模块化，使得复杂的代码按模块来分，细化代码的粒度；<br>less、sass等css预处理器；<br>typescript等在js基础上扩展的语言；<br>es6等js的进阶语言；<br>……<br><a id="more"></a><br>这些技术的确提高了我们的开发效率，也使得代码更加简化、强大，然而，浏览器并不能识别这些语言，那是不是得做些什么呢？因此，就出现了类似webpack这样的牛逼工具。<br>至于他跟其他类似工具（Gulp、Grunt等）的区别可以去查阅其他资料（主要是因为写这篇博客时我也不大懂其他几个工具哈哈哈~）<br>让我们慢慢来了解它吧~</p><h2 id="什么是webpack？"><a href="#什么是webpack？" class="headerlink" title="什么是webpack？"></a>什么是webpack？</h2><p>webpack是一个模块打包器，负责打包转换所依赖的各类资源，将他们转换为浏览器所能认识的文件格式。可以通俗地把webpack理解成食品加工厂，你直接把这些原材料简单混合在一起是无法做出美味的食品的，必须经过各个环节的加工，转换，才能让大家吃到最终的好吃的食品。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="开始前准备"><a href="#开始前准备" class="headerlink" title="开始前准备"></a>开始前准备</h3><p>首先我们先init一个npm项目：npm init，这样package.json文件就准备好了；<br>接着安装webpack工具，推荐局部安装（npm install -D webpack），因为各个项目要用的webpack版本可能不同，并且有些老项目用的也可能还是旧版本的webpack。</p><h3 id="开始使用webpack"><a href="#开始使用webpack" class="headerlink" title="开始使用webpack"></a>开始使用webpack</h3><p>在项目底下创建src和dist文件夹，并创建src/index.js，src/hello.js，dist/index.html文件，内容分别如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//src/index.js</div><div class="line">import hello from &apos;./hello&apos;;</div><div class="line">function component () &#123;</div><div class="line">  hello();</div><div class="line">  var element = document.createElement(&apos;div&apos;);</div><div class="line">  element.innerHTML = &apos;Enjoy your journey~&apos;;</div><div class="line">&#125;</div><div class="line">document.body.appendChild(component());</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//src/hello.js</div><div class="line">export default function hello () &#123;</div><div class="line">  console.log(&apos;Hi, my good friend!&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//dist/index.html</div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">  &lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;Webpack App&lt;/title&gt;</div><div class="line">  &lt;/head&gt;</div><div class="line">  &lt;body&gt;</div><div class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;bundle.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><p>准备好这些文件之后，就可以开始运行webpack了，命令格式：webpack {entry文件} {output文件}，由于是局部安装的webpack，我们应该找到具体的webpack，具体命令为：./node_modules/.bin/webpack src/index.js dist/bundle.js，执行完后会发现dist文件夹里多出来了一个bundle.js文件，也就是我们前面index.html里用到的js。此时打开index.html页面就可以看到预期效果啦~</p><h3 id="通过配置文件来使用webpack"><a href="#通过配置文件来使用webpack" class="headerlink" title="通过配置文件来使用webpack"></a>通过配置文件来使用webpack</h3><p>大多数项目都会用到很复杂的webpack配置，而非只有简单的entry和output，因此webpack支持配置文件，默认读取webpack.config.js里的配置，否则通过webpack –config {配置文件} 来更改默认配置文件，eg：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//webpack.config.js</div><div class="line">function resolve (dir) &#123;</div><div class="line">  return path.resolve(__dirname, &apos;./&apos;, dir)</div><div class="line">&#125;</div><div class="line">module.exports = &#123;</div><div class="line">  entry: &#123;</div><div class="line">    main: resolve(&apos;src/index.js&apos;)</div><div class="line">  &#125;,</div><div class="line">  output: &#123;</div><div class="line">    path: resolve(&apos;dist&apos;),</div><div class="line">    filename: &apos;bundle.js&apos;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>拥有了配置文件后，就可以直接执行./node_modules/.bin/webpack ，不用在执行命令时指定相应entry和output等配置了，而是把这些配置信息放在了配置文件。</p><h3 id="通过npm脚本来使用webpack"><a href="#通过npm脚本来使用webpack" class="headerlink" title="通过npm脚本来使用webpack"></a>通过npm脚本来使用webpack</h3><p>考虑到直接用命令行来运行本地的webpack不是很方便，还得找到webpack的具体位置，webpack提供了更快捷的方式，即在npm脚本中指定具体的脚本命令，eg：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//package.json</div><div class="line">&#123;</div><div class="line">  ...</div><div class="line">  &quot;scripts&quot;: &#123;</div><div class="line">    &quot;start&quot;: &quot;webpack&quot;</div><div class="line">  &#125;,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>注意：1、npm项目的标准是允许我们直接引用本地安装的npm包，所以无需指出完整路径，而是直接执行webpack命令； 2、可以直接使用npm start命令来运行webpack，start命令可以使用简便方式（原本命令是npm run start）。</p><h3 id="通过HtmlWebpackPlugin来自动生成index-html"><a href="#通过HtmlWebpackPlugin来自动生成index-html" class="headerlink" title="通过HtmlWebpackPlugin来自动生成index.html"></a>通过HtmlWebpackPlugin来自动生成index.html</h3><p>假如我们的入口js文件名每次都是不一样，比如添加了[hash]，或突然又新增了一个入口文件，那我们是要每次都修改index.html文件吗？HtmlWebpackPlugin插件（插件在下文plugin模块介绍） 解决了此问题，通过这个插件，我们可以指定一个基础的模板，而它依赖的文件都是通过该插件自动生成的。<br>1）首先我们先安装这个插件：npm install -D html-webpack-plugin<br>2）然后，创建基础模板（src/index.tmpl.html）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//index.tmpl.html</div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">  &lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</div><div class="line">    &lt;title&gt;Webpack Sample Project&lt;/title&gt;</div><div class="line">  &lt;/head&gt;</div><div class="line">  &lt;body&gt;</div><div class="line">    &lt;div id=&apos;root&apos;&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p><p>3）接着就可以在配置文件中添加该插件，指定基础模板：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//webpack.config.js</div><div class="line">plugins: [</div><div class="line">  new HtmlWebpackPlugin(&#123;</div><div class="line">    template: __dirname + &quot;/src/index.tmpl.html&quot;</div><div class="line">  &#125;)</div><div class="line">]</div></pre></td></tr></table></figure></p><p>4）此时，我们可以删除dist文件夹了，再次执行npm start后dist/index.html和dist/bundle.js都会自动生成。</p><h3 id="构建本地服务器"><a href="#构建本地服务器" class="headerlink" title="构建本地服务器"></a>构建本地服务器</h3><p>通过webpack-dev-server，我们可以让我们的项目像服务器那样在本地跑起来，这个本地服务器基于nodejs构建。<br>1）首先，安装webpack-dev-server：npm install -D webpack-dev-server；<br>2）然后，在配置文件中添加devServer配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//webpack.config.js</div><div class="line">devServer: &#123;</div><div class="line">  contentBase: resolve(&apos;dist&apos;)//指定本地服务器所加载的页面所在的目录</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>3）修改start命令为：webpack –open<br>当我们再次npm start时，就会自动打开<a href="http://localhost:8080看到我们的index页面了。" target="_blank" rel="external">http://localhost:8080看到我们的index页面了。</a></p><p>至此，我们已经实现了一个基本的构建过程，接下来我们要一一来介绍webpack最重要的几个概念：entry，output，loader，plugin。</p><h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><p>entry配置打包的入口文件，从入口文件开始画出依赖图谱，可以是一条或多条相互独立的依赖图谱，具体有三种用法：</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>我们先从对象说起，因为其他两种都是对象形式的简写，对象形式由键值对（key: value）组成，eg：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//webpack.config.js</div><div class="line">entry: &#123;</div><div class="line">  &apos;entry1&apos;: path1,</div><div class="line">  &apos;entry2&apos;: path2</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>注意，这边的key对应output的[name]，若output的filename设置成[name].bundle.js，则会生成entry1.bundle.js和entry2.bundle.js。value可以是路径，也可以是npm模块（以下path都是有这两种形式）如：’lodash’，还可以是数组， 。<br>应用：多页应用就是用对象形式的，多页应用有很多独立的html，分别有自己的入口文件和独立的依赖图谱。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>eg：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//webpack.config.js</div><div class="line">entry: path1</div></pre></td></tr></table></figure></p><p>等价于下面的对象形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//webpack.config.js</div><div class="line">entry: &#123;</div><div class="line">  &apos;main&apos;: path1</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>应用： 单页应用一般是字符串形式，指定一个main入口。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>eg：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//webpack.config.js</div><div class="line">entry: [path1, path2]</div></pre></td></tr></table></figure></p><p>等价于下面的对象形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//webpack.config.js</div><div class="line">entry: &#123;</div><div class="line">  &apos;main&apos;: [path1, path2]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>应用：entry: [‘./app.js’,  ‘lodash’, ‘jquery’]，将lodash和jquery一起打包进入口文件。</p><h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><p>output配置打包的输出文件，至少应该有两项配置：filename和path，filename表示输出的文件名，path表示把文件输出到哪个目录，即使指定多个入口文件时，我们也只指定一个输出配置，可以结合[name]（对应entry的对象格式的key）, [hash]（对应整个编译过程的hash，每次构建只生成一个hash）, [chunkhash]（对应chunk的hash），eg：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//webpack.config.js</div><div class="line">output: &#123;</div><div class="line">  &apos;filename&apos;: [name].bundle.js,</div><div class="line">  &apos;path&apos;: resolve(&apos;dist&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>假设entry：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//webpack.config.js</div><div class="line">entry: &#123;</div><div class="line">  &apos;entry1&apos;: path1,</div><div class="line">  &apos;entry2&apos;: path2</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>则输出’./dist/entry1.bundle.js’和’./dist/entry2.bundle.js’。<br>其他配置请查看官网文档。</p><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>我认为loader是webpack最强大的功能了，它的作用是通过调用外部的脚本或工具（loader），来把各种格式的文件（es6, less, sass, jsx等）处理为浏览器所能识别的格式（css, js等），一次处理一个文件。</p><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>要使用loader，首先要先安装它，并在配置文件中的modules.rules做相关配置，有这些主要配置：</p><ul><li>test：用于匹配loader要处理的文件的正则（required）</li><li><p>use：可以配置loader的除了test的各种属性，可以是个对象或数组（数组时执行顺序是由下而上），eg：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//对象</div><div class="line">use: &#123;</div><div class="line">  loader: &apos;url-loader&apos;,</div><div class="line">  options: &#123;</div><div class="line">    limit: 10000,</div><div class="line">    name: &apos;img/[name].[hash:7].[ext]&apos;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//数组</div><div class="line">use: [&#123;</div><div class="line">  loader: &apos;style-loader&apos;</div><div class="line">&#125;, &#123;</div><div class="line">  loader: &apos;css-loader&apos;</div><div class="line">&#125;, &#123;</div><div class="line">  loader: &apos;less-loader&apos;</div><div class="line">&#125;]</div></pre></td></tr></table></figure></li><li><p>loader：loader的名称，use.loader的简写，多个loader可以用!分隔，执行顺序是从右往左，例如loader: style-loader!css-loader!less-loader的执行顺序是less-loader–&gt;css-loader–&gt;style-loader（required）</p></li><li>include：把匹配范围限定在include指定的范围内（可选）</li><li>exclude：把匹配范围从exclude指定的范围排除（可选）</li><li>options：为loader设置额外选项，use.options的简写（可选）</li></ul><h3 id="常见loader"><a href="#常见loader" class="headerlink" title="常见loader"></a>常见loader</h3><p>接下来，我们来看些常用的loader：</p><h4 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h4><p>babel其实包含好几个模块，你要用几个模块的功能就得安装几个包，其核心功能在babel-core，常用的babel包有babel-preset-es2015（用于解析es6）和babel-preset-react（用于解析jsx）。</p><p>首先，我们先安装这些安装包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -D babel-loader babel-core babel-preset-es2015 babel-preset-react</div></pre></td></tr></table></figure></p><p>然后配置babel-loader：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//webpack.config.js</div><div class="line">rules: [&#123;</div><div class="line">  test: /(\.js|\.jsx)$/,</div><div class="line">  use: &#123;</div><div class="line">    loader: &apos;babel-loader&apos; ,</div><div class="line">    options: &#123;</div><div class="line">      presets: [</div><div class="line">        &quot;es2015&quot;, &quot;react&quot;</div><div class="line">      ]</div><div class="line">    &#125;,</div><div class="line">  &#125;</div><div class="line">  include: resolve(&apos;src&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>babel-loader支持把options配置单独放在.babelrc文件中，eg：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//.babelrc</div><div class="line">&#123;</div><div class="line">  &quot;presets&quot;: [&quot;react&quot;]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>接下来就可以使用es6和jsx语法了（注意要使用react时记得先安装react和react-dom），eg：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//Greeter.js</div><div class="line">class Greeter extends Component&#123;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;div className=&quot;test&quot;&gt;</div><div class="line">        qqaaaaa</div><div class="line">      &lt;/div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export default Greeter</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//main.js</div><div class="line">import React from &apos;react&apos;;</div><div class="line">import &#123;render&#125; from &apos;react-dom&apos;;</div><div class="line">import Greeter from &apos;./Greeter&apos;;</div><div class="line">import &apos;./Greeter.less&apos;;</div><div class="line"></div><div class="line">render(&lt;Greeter /&gt;, document.getElementById(&apos;root&apos;));</div></pre></td></tr></table></figure><p>重新启动时，页面正常渲染。</p><h4 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h4><p>如果要处理一个less样式文件，我们需要用到三个loader：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">use: [&#123;</div><div class="line">  loader: &apos;style-loader&apos;</div><div class="line">&#125;, &#123;</div><div class="line">  loader: &apos;css-loader&apos;</div><div class="line">&#125;, &#123;</div><div class="line">  loader: &apos;less-loader&apos;</div><div class="line">&#125;]</div></pre></td></tr></table></figure></p><p>这三个loader作用分别如下：</p><ul><li>less-loader：为了在js中通过require或import的方式引入less文件</li><li>css-loader：为了在js中通过require或import的方式引入css文件</li><li>style-loader：为了在html中一style的方式嵌入css，将所有计算后的样式加入页面中</li></ul><p>注意，这三个loader的执行顺序应该是：less-loader–&gt;less-loader–&gt;style-loader</p><h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>插件和loader不一样，loader是针对某些文件进行格式转换处理，一次处理一个文件，而plugins是在整个构建过程中起作用，具体地说应该是打点执行相关任务（在某个构建钩子定义好了要执行哪些任务）。<br>使用插件前我们也是需要npm安装好插件，webpack内置的插件不需要。</p><h3 id="常见plugin"><a href="#常见plugin" class="headerlink" title="常见plugin"></a>常见plugin</h3><p>接下来，我们来看些常用的plugin：</p><h3 id="HtmlWebpackPlugin（index-html模板插件）"><a href="#HtmlWebpackPlugin（index-html模板插件）" class="headerlink" title="HtmlWebpackPlugin（index.html模板插件）"></a>HtmlWebpackPlugin（index.html模板插件）</h3><p>此插件在webpack基本使用一节已经讲过，此处略过。</p><h4 id="HotModuleReplacement-（HMR热更新插件-）"><a href="#HotModuleReplacement-（HMR热更新插件-）" class="headerlink" title="HotModuleReplacement （HMR热更新插件 ）"></a>HotModuleReplacement （HMR热更新插件 ）</h4><p>该插件是webpack内置插件，所以无需安装。<br>需要在webpack配置文件中添加该插件，并且为devServer添加hot参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//webpack.config.js</div><div class="line">var webpack = require(&apos;webpack&apos;);</div><div class="line">module.exports = &#123;</div><div class="line">  ...</div><div class="line">  devServer: &#123;</div><div class="line">    contentBase: resolve(&apos;dist&apos;),</div><div class="line">    hot: true</div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    new webpack.HotModuleReplacementPlugin()</div><div class="line">  ]</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>但是，react模块似乎还是无法热更新，此时我们要结合babel（react-transform-hrm）来实现react的热更新功能：<br>首先安装react-transform-hrm： npm install -D babel-plugin-react-transform react-transform-hmr；<br>然后添加babel配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//.babelrc</div><div class="line">&#123;</div><div class="line">  &quot;presets&quot;: [&quot;react&quot;],</div><div class="line">  &quot;env&quot;: &#123;</div><div class="line">    &quot;development&quot;: &#123;</div><div class="line">      &quot;plugins&quot;: [[&quot;react-transform&quot;, &#123;</div><div class="line">        &quot;transforms&quot;: [&#123;</div><div class="line">          &quot;transform&quot;: &quot;react-transform-hmr&quot;,</div><div class="line">          &quot;imports&quot;: [&quot;react&quot;],</div><div class="line">          &quot;locals&quot;: [&quot;module&quot;]</div><div class="line">         &#125;]</div><div class="line">      &#125;]]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这下，react模块就可以热更新啦。</p><h4 id="CommonsChunkPlugin（代码分离–去重和分离chunk-）"><a href="#CommonsChunkPlugin（代码分离–去重和分离chunk-）" class="headerlink" title="CommonsChunkPlugin（代码分离–去重和分离chunk ）"></a>CommonsChunkPlugin（代码分离–去重和分离chunk ）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">new webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">  name: &apos;common&apos; // 指定公共 bundle 的名称。</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>或：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">new webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">  name: &apos;vendor&apos;,</div><div class="line">  minChunks: function(module, count) &#123;</div><div class="line">    const recource = module.recource;</div><div class="line">    return recource &amp;&amp; /\.js$/.test(recource) &amp;&amp; recource.indexOf(resolve(&apos;node_modules&apos;)) === 0;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><h4 id="ExtractTextPlugin（代码分离–将css从主程序中分离-）"><a href="#ExtractTextPlugin（代码分离–将css从主程序中分离-）" class="headerlink" title="ExtractTextPlugin（代码分离–将css从主程序中分离 ）"></a>ExtractTextPlugin（代码分离–将css从主程序中分离 ）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var extractBaseCSS = new ExtractTextPlugin(&#123;</div><div class="line">  filename: getExtractFilename(&apos;development&apos;, &apos;base&apos;)</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>1、loader<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  test: /\.css$/,</div><div class="line">  use: extractBaseCSS.extract(&#123;</div><div class="line">    fallback: &apos;style-loader&apos;,</div><div class="line">    use: &apos;css-loader&apos;</div><div class="line">  &#125;)</div><div class="line">&#125;, &#123;</div><div class="line">  test: /\.less$/,</div><div class="line">  use: extractBaseCSS.extract(&#123;</div><div class="line">    fallback: &apos;style-loader&apos;,</div><div class="line">    use: [&apos;css-loader&apos;, &apos;less-loader&apos;]</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>2、plugin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">plugins: [</div><div class="line">  extractBaseCSS</div><div class="line">]</div></pre></td></tr></table></figure></p><h4 id="UglifyJsPlugin（js代码压缩插件）"><a href="#UglifyJsPlugin（js代码压缩插件）" class="headerlink" title="UglifyJsPlugin（js代码压缩插件）"></a>UglifyJsPlugin（js代码压缩插件）</h4><p>一般只用于线上环境的构建。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">plugins: [</div><div class="line">  new UgligyFsWebpackPlugin(&#123;</div><div class="line">    filename: cssFilename</div><div class="line">  &#125;)</div><div class="line">]</div></pre></td></tr></table></figure></p><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>怎样使浏览器用缓存的资源来加快访问速度呢？可以这样做：<br>将output.filename设置为[chunkhash]组合，eg：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">output: &#123;</div><div class="line">    path: resolve(&apos;dist&apos;),</div><div class="line">    filename: &apos;[name].[chunkhash].js&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>再将第三方库抽离（变动很少）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">new webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">    name: &apos;vendor&apos;,</div><div class="line">    minChunks: function(module, count) &#123;</div><div class="line">         const recource = module.recource;</div><div class="line">         return recource &amp;&amp; /\.js$/.test(recource) &amp;&amp; recource.indexOf(resolve(&apos;node_modules&apos;)) === 0;</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>这样，浏览器就可以缓存那些没变动的文件。</p><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>想要区分环境，可以通过webpack –env配置环境变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack --config webpack.prod.js --env.NODE_ENV=production</div></pre></td></tr></table></figure></p><p>或：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack --config webpack.prod.js --env.production（不设置具体值时默认true）</div></pre></td></tr></table></figure></p><p>设置完，webpack.config.js原本是exports出一个对象，想要使用env变量，必须exports出一个function，return一个对象，eg：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">module.exports = (env) =&gt; &#123;</div><div class="line">    console.log(&apos;devenv&apos;, env)</div><div class="line">    return merge(common(env), &#123;</div><div class="line">        devtool: &apos;inline-source-map&apos;,</div><div class="line">        devServer: &#123;</div><div class="line">            contentBase: resolve(&apos;dist&apos;),</div><div class="line">            hot: true</div><div class="line">        &#125;,</div><div class="line">        plugins: [</div><div class="line">            new webpack.HotModuleReplacementPlugin()</div><div class="line">        ]</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="构建环境配置分离"><a href="#构建环境配置分离" class="headerlink" title="构建环境配置分离"></a>构建环境配置分离</h2><p>配置<br>可以为生产环境和开发环境分别配置webpack，将webpack.config.js拆分为webpack.common.js+webpack.prod.js+webpack.dev.js</p><p>npm script<br>将dev和prod环境的相关命令分别修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">start:  &quot;webpack-dev-server --open --config webpack.dev.js&quot;,</div><div class="line">build:  &quot;webpack --config webpack.prod.js&quot;</div></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>感谢阅读，至此相信你已经基本了解了webpack，认识到webpack的强大了吗？文章似乎已经有点长了，并且有点晚了，就先写到这啦~</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;入门&quot;&gt;&lt;a href=&quot;#入门&quot; class=&quot;headerlink&quot; title=&quot;入门&quot;&gt;&lt;/a&gt;入门&lt;/h1&gt;&lt;h2 id=&quot;为什么要用webpack？&quot;&gt;&lt;a href=&quot;#为什么要用webpack？&quot; class=&quot;headerlink&quot; title=&quot;为什么要用webpack？&quot;&gt;&lt;/a&gt;为什么要用webpack？&lt;/h2&gt;&lt;p&gt;现如今网页丰富多样，很多网页都相当复杂，它们拥有复杂的js和各种依赖包，目前也有很多技术用于简化这些代码，例如：&lt;br&gt;模块化，使得复杂的代码按模块来分，细化代码的粒度；&lt;br&gt;less、sass等css预处理器；&lt;br&gt;typescript等在js基础上扩展的语言；&lt;br&gt;es6等js的进阶语言；&lt;br&gt;……&lt;br&gt;
    
    </summary>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>vue虚拟dom</title>
    <link href="http://yoursite.com/2017/10/23/vue-virtual-dom/"/>
    <id>http://yoursite.com/2017/10/23/vue-virtual-dom/</id>
    <published>2017-10-23T10:28:21.000Z</published>
    <updated>2017-10-28T12:33:03.773Z</updated>
    
    <content type="html"><![CDATA[<p>本文将结合<a href="https://github.com/vuejs/vue" target="_blank" rel="external">vue2.0</a>源码向各位介绍下vue virtual dom。</p><h1 id="什么是virtual-dom"><a href="#什么是virtual-dom" class="headerlink" title="什么是virtual dom"></a>什么是virtual dom</h1><p>vue2.0和react都引入了virtual dom的概念，virtual dom就是一种在js中模拟dom对象树来优化dom操作的技术或思想。</p><a id="more"></a><h1 id="为什么要引入vdom"><a href="#为什么要引入vdom" class="headerlink" title="为什么要引入vdom"></a>为什么要引入vdom</h1><p>1、dom元素太复杂，如果每次都重新生成dom元素，浪费性能。<br>做个实验，打印出一个空元素的属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var testDiv = document.createElement(&apos;div&apos;);</div><div class="line">for(var attr in testDiv )&#123;</div><div class="line">  console.log(attr)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>打印结果可以看出，dom元素的属性太多了，而vdom定义了真实dom的一些关键信息，这样模拟出来的虚拟dom对象简单的很多（vnode）。</p><p>2、创建dom，删除dom，插入dom等一系列dom操作很耗性能。<br>而vdom很好地对dom做了一层映射关系，进而将dom的一系列操作映射到了操作vdom。<br>vdom完全是由js实现的，和浏览器没有任何关系，得益于js的执行速度，相比于操作真实dom，提高了效率和性能。eg：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//伪代码</div><div class="line">var mydivVirtual = &#123; </div><div class="line">  tagName: &apos;DIV&apos;,</div><div class="line">  className: &apos;a&apos;</div><div class="line">&#125;;</div><div class="line">var newmydivVirtual = &#123;</div><div class="line">   tagName: &apos;DIV&apos;,</div><div class="line">   className: &apos;b&apos;</div><div class="line">&#125;</div><div class="line">if(mydivVirtual.tagName !== newmydivVirtual.tagName || mydivVirtual.className  !== newmydivVirtual.className) &#123;</div><div class="line">   change(mydiv)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 会执行相应的修改 mydiv.className = &apos;b&apos;;</div><div class="line">//最后  &lt;div class=&apos;b&apos;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p><h1 id="VNode"><a href="#VNode" class="headerlink" title="VNode"></a>VNode</h1><p>接下来，我们来了解下VNode：<br>页面上每个节点都有对应的vnode，vnode的几个比较重要的属性：</p><ul><li>tag：即这个vnode的标签属性</li><li>data：包含了最后渲染成真实dom节点后，节点上的class,attribute,style以及绑定的事件</li><li>children：是vnode的子节点</li><li>text：是文本属性（只有文本节点和注释节点该属性才有值）</li><li>elm：为这个vnode对应的真实dom节点</li><li>key：是vnode的标记，在diff过程中可以提高diff的效率，后文有讲解<br>…..</li></ul><h1 id="vdom的实现"><a href="#vdom的实现" class="headerlink" title="vdom的实现"></a>vdom的实现</h1><p>先来看下整体流程：<br><img src="http://res.cloudinary.com/dbdwyv3dv/image/upload/v1508762939/flow-chart_kb8m9t.png" alt="vdom的整体流程图"><br>首先，组件初始化（init）时挂载了组件（mountComponent）:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//vue组件初始化</div><div class="line">function init () &#123;</div><div class="line">  ...</div><div class="line">  //组件挂载</div><div class="line">  mountComponent();</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>组件挂载（mountComponent）时，定义了updateComponent函数，实际执行update，update的第一个参数是由render生成的一个vnode节点，同时初始化了watcher，记录了数据的依赖，当data changed时，会进行update：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//组件挂载</div><div class="line">function mountComponent () &#123;</div><div class="line">  ...</div><div class="line">  let updateComponent = () =&gt; &#123;</div><div class="line">    //render()结果是一个新的vnode</div><div class="line">    update(render(), ...);</div><div class="line">  &#125;</div><div class="line">  //把updateComponent方法传进watcher，watcher记录了数据依赖，data changed时，执行updateComponent</div><div class="line">  new Watcher(..., updateComponent, ...);</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>其中，watcher的实现，对数据进行监听：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function Watcher () &#123;</div><div class="line">  ...</div><div class="line">  收集数据依赖</div><div class="line">  ...</div><div class="line">  data changed --&gt; updateComponent</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>render的实现，返回vnode节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function render () &#123;</div><div class="line">  ...</div><div class="line">  let vnode = createElement();</div><div class="line">  ...</div><div class="line">  return vnode;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>createElement的实现，创建vnode节点 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function createElement() &#123;</div><div class="line">  ...</div><div class="line">  let vnode = new Vnode();</div><div class="line">  ...</div><div class="line">  return vnode;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>update包括diff（对新旧vnode进行比较）和patch（根据diff结果在oldVNode上面打的补丁更新真实dom）的过程（代码里就是指patch， patchVnode， updateChildren几个方法的过程），算法基于snabbdom算法，复杂度为O(n)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//更新</div><div class="line">function update (vnode, ...) &#123;</div><div class="line">  ...</div><div class="line">  if(!prevVnode) &#123;//如果prevVnode不存在，就用新的vnode来创建真实的dom</div><div class="line">    ...</div><div class="line">    patch(..., vnode, ...);</div><div class="line">    ...</div><div class="line">  &#125; else &#123;//prevVNode存在，就对prevVnode和vnode进行diff，并将需要更新的dom以patch的形式打到prevVnode上，并完成真实的dom的更新工作</div><div class="line">    ...</div><div class="line">    patch(prevVnode, vnode, ...);</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>其中，patch是virtual dom的核心方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//virtual dom的核心方法，主要完成了prevVnode和vnode的diff，并根据需要打patch，最后完成真实dom的更新工作。</div><div class="line">function patch (oldVnode, vnode) &#123;</div><div class="line">  ...</div><div class="line">  if(isUndef(oldVnode)) &#123;//oldVnode不存在时，在父节点底下直接创建新的子节点</div><div class="line">    createElm(vnode, ..., parentElm);</div><div class="line">  &#125; else &#123;</div><div class="line">    if(sameVnode(oldVnode, vnode)) &#123;//两个节点基本属性一致时，对oldVnode和vnode进行diff，并对oldVnode打patch</div><div class="line">      patchVnode(oldVnode, vnode, ...);</div><div class="line">    &#125; else &#123;//否则跳过diff，直接根据vnode创建一个新的dom，同时删除老的dom</div><div class="line">      createElm(vnode, ..., parentElm);</div><div class="line">      removeElm(oldVnode, ..., parentElm);</div><div class="line">      ...</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>sameVNode用来比较两个节点的基本属性是否一致，一致时表示两个节点值得对比，才进行diff，否则无需对比，直接生成新的dom：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//判断两个节点的基本属性是否一致，是否值得比较</div><div class="line">function sameVnode(a, b) &#123;</div><div class="line">  return (</div><div class="line">    a.key === b.key &amp;&amp;</div><div class="line">    a.tag === b.tag &amp;&amp;</div><div class="line">    a.isComment === b.isComment &amp;&amp;</div><div class="line">    isDef(a.data) === isDef(b.data) &amp;&amp;</div><div class="line">    sameInputType(a, b)</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>接下来，patchVnode又分了好几种情况：<br>1、首先进行文本节点的判断，若oldVnode.text !== vnode.text，那么就会直接进行文本节点的替换；<br>2、在vnode没有文本节点的情况下，进入子节点的diff；<br>3、当oldCh和ch都存在且不相同的情况下，调用updateChildren对子节点进行diff；<br>4、 若oldCh不存在，ch存在，首先清空oldVnode的文本节点，同时调用addVnodes方法将ch添加到elm真实dom节点当中；<br>5、若oldCh存在，ch不存在，则删除elm真实节点下的oldCh子节点；<br>6、若oldVnode有文本节点，而vnode没有，那么就清空这个文本节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">//</div><div class="line">function patchVnode(oldVnode, vnode) &#123;</div><div class="line">  const elm = vnode.elm = oldVnode.elm,//在patch之前，vnode的属性是null的，因为在patch之前还没真实的dom，此处vnode的el属性引用的是oldVnode的el属性</div><div class="line">    oldCh = oldVnode.children,</div><div class="line">    ch = vnode.children;</div><div class="line">  if(ifUndef(vnode.text)) &#123;//vnode没有文本节点</div><div class="line">    if(isDef(oldCh) &amp;&amp; isDef(ch)) &#123;//oldVnode和vnode都有children</div><div class="line">      //对子节点进行diff</div><div class="line">      updateChildren(elm, oldCh, ch, ...);</div><div class="line">    &#125; else if(isDef(ch)) &#123;//只有vnode存在children</div><div class="line">      if(ifDef(oldVnode.text)) &#123;//若oldVnode有text，清空原来的文本节点</div><div class="line">        nodeOps.setTextContent(elm, &apos;&apos;);</div><div class="line">      &#125;</div><div class="line">      //同时将ch添加到elm真实的dom节点中</div><div class="line">      addVnodes(elm, ch, ...);</div><div class="line">    &#125; else if(isDef(oldCh)) &#123;//只有oldVnode存在children</div><div class="line">      //删除elm下的oldCh节点</div><div class="line">      removeVnode(elm, oldCh, ...);</div><div class="line">    &#125; else if(isDef(oldVnode.text)) &#123;//只有oldVnode有文本节点，那就清空这个文本节点</div><div class="line">      nodeOps.setTextContent(elm, &apos;&apos;);</div><div class="line">    &#125;</div><div class="line">  &#125; else if(ifDef(oldVnode.text !== vnode.text)) &#123;//vnode有文本节点，直接将elm的内容设为该文本</div><div class="line">    nodeOps.setTextContent(elm, vnode.text);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>updateChildren是diff的核心：<br>首先，给oldVnode和vnode的firstChild和lastChild分别设置oldStartVnode,oldEndVnode,newStartVnode,newEndVnode,接着开始patch：<br>1）如果oldStartVnode和newStartVnode基本属性相同，调用patchVnode进行patch，然后将oldStartVnode和newStartVnode都设置为下一子节点，重复上述流程：<br><img src="http://res.cloudinary.com/dbdwyv3dv/image/upload/v1508762938/sameVnode_oldStartVnode_newStartVnode_vrpayg.png" alt="sameVnode(oldStartVnode, newStartVnode)"><br>2）如果oldEndVnode和newEndVnode基本属性相同，调用patchVnode进行patch，然后将oldEndVnode和newEndVnode都设为上一子节点，重复上述流程：<br><img src="http://res.cloudinary.com/dbdwyv3dv/image/upload/v1508762940/sameVnode_oldEndVnode_newEndVnode_nirxo0.png" alt="sameVnode(oldEndVnode, newEndVnode)"><br>3）如果oldStartVnode和newEndVnode基本属性相同，调用patchVnode进行patch，把oldStartVnode.elm移至oldEndVnode.elm之后，然后把oldStartVnode设为下一子节点，把newEndVnode设为上一子节点，重复上述流程：<br><img src="http://res.cloudinary.com/dbdwyv3dv/image/upload/v1508762944/sameVnode_oldStartVnode_newEndVnode_ennsvf.png" alt="sameVnode(oldStartVnode, newEndVnode)"><br>4）如果oldEndVnode和newStartVnode基本属性相同，调用patchVnode进行patch，把oldEndVnode.elm移至oldStartVnode.elm之后，然后把oldEndVnode 设为上一子节点，把newStartVnode设为下一子节点，重复上述流程：<br><img src="http://res.cloudinary.com/dbdwyv3dv/image/upload/v1508762940/sameVnode_oldEndVnode_newStartVnode_m43yxw.png" alt="sameVnode(oldEndVnode, newStartVnode)"><br>5）如果上述都不匹配，则尝试在oldChildren中查找与newStartVnode的key相同的子节点：<br>&ensp;&ensp;如果找不到相同key子节点，说明newStartVnode是一个新节点，就在oldStartVnode.elm前创建一个新节点，并把newStartVnode设为下一个节点，重复上述流程；<br>&ensp;&ensp;如果找得到相同key子节点，就比较这两个节点基本属性是否相同：<br>&ensp;&ensp;&ensp;&ensp;如果相同，就调用patchVnode进行patch，把找到的节点移到oldStartVnode之前，并把newStartVnode设为下一个节点，重复上述流程：<br>&ensp;&ensp;&ensp;&ensp;<img src="http://res.cloudinary.com/dbdwyv3dv/image/upload/v1508762940/key%E5%8C%B9%E9%85%8D%E4%B8%94sameVnode_uqpdyf.png" alt="key匹配且sameVnode"><br>&ensp;&ensp;&ensp;&ensp;如果不相同，则说明newStartVnode是一个新节点，就在oldStartVnode.elm前创建一个新节点，并把newStartVnode设为下一个节点，重复上述流程；</p><p>如果oldStartVnode和oldEndVnode重合了，或newStartVnode和newEndVnode重合了，表示diff结束了，如果oldChildren还有剩余节点，说明这些旧的节点已经不需要了，删除这些旧节点，如果newChildren还有剩余节点，说明这些节点是多出来的，新增这些子节点。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>引入虚拟dom实际上有优点也有缺点：</p><h2 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h2><p>更多的功能意味着更多的代码。幸运的是vue.js 2.0仍是相当小的（20+k）；</p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>虚拟dom需要在内存中维护一份dom的副本。需要在更新速度和使用内存空间取得平衡。</p><h2 id="不是适合所有情况"><a href="#不是适合所有情况" class="headerlink" title="不是适合所有情况"></a>不是适合所有情况</h2><p>如果需要大量修改dom，虚拟dom是合适的，但是如果是单一的，但又需要频繁更新的话，虚拟dom将会花费更多的时间处理计算的工作。所以，如果你有一个dom相对较少的界面，用虚拟dom，可能会更慢。但对于绝大多数情况，应该是合适的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将结合&lt;a href=&quot;https://github.com/vuejs/vue&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;vue2.0&lt;/a&gt;源码向各位介绍下vue virtual dom。&lt;/p&gt;
&lt;h1 id=&quot;什么是virtual-dom&quot;&gt;&lt;a href=&quot;#什么是virtual-dom&quot; class=&quot;headerlink&quot; title=&quot;什么是virtual dom&quot;&gt;&lt;/a&gt;什么是virtual dom&lt;/h1&gt;&lt;p&gt;vue2.0和react都引入了virtual dom的概念，virtual dom就是一种在js中模拟dom对象树来优化dom操作的技术或思想。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
      <category term="virtual dom" scheme="http://yoursite.com/tags/virtual-dom/"/>
    
  </entry>
  
</feed>
